<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>VLAAI DOOM</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; font-family:'Impact',sans-serif; }
canvas { display:block; image-rendering: pixelated; }

#overlay, #gameover {
  position:fixed; inset:0;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  z-index:50; color:#fff;
}
#overlay { background:radial-gradient(ellipse at center,#1a0005,#000); }
#gameover { background:rgba(0,0,0,0.92); display:none; }

h1.doom-title {
  font-size:clamp(40px,8vw,80px); letter-spacing:8px;
  color:#ff2200; text-shadow:0 0 30px #ff2200,0 0 60px #990000;
  margin-bottom:6px;
}
h2.doom-sub {
  font-size:clamp(16px,3vw,26px); color:#ffaa00;
  text-shadow:0 0 12px #ff6600; margin-bottom:20px; letter-spacing:4px;
}
.doom-info { font-size:clamp(11px,1.8vw,15px); color:#aaa; margin:3px 0; font-family:monospace; }
.doom-btn {
  margin-top:24px; padding:14px 44px; font-size:clamp(16px,2.5vw,22px);
  background:linear-gradient(#c83000,#7a1000); color:#fff;
  border:2px solid #ff4400; border-radius:3px; cursor:pointer;
  font-family:'Impact',sans-serif; letter-spacing:3px;
  box-shadow:0 0 24px #ff2200; transition:transform .1s,box-shadow .1s;
}
.doom-btn:hover { transform:scale(1.04); box-shadow:0 0 36px #ff4400; }

#hud {
  position:fixed; bottom:0; left:50%; transform:translateX(-50%);
  display:none; align-items:stretch;
  background:linear-gradient(#111,#1a1a1a);
  border-top:3px solid #444;
  z-index:20; user-select:none;
}
.hud-panel {
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  padding:6px 18px; border-right:2px solid #333; min-width:90px;
}
.hud-panel:last-child { border-right:none; }
.hud-lbl { font-size:11px; color:#cc2200; letter-spacing:2px; margin-bottom:2px; }
.hud-val { font-size:32px; color:#ff6600; line-height:1; }
#hud-face { width:72px; height:72px; border:2px solid #555; overflow:hidden; }
#hud-face canvas { width:72px; height:72px; }

#killmsg, #wavemsg {
  position:fixed; left:50%; transform:translateX(-50%);
  pointer-events:none; z-index:30; white-space:nowrap;
  font-size:clamp(22px,4vw,40px); text-shadow:0 0 20px currentColor;
  opacity:0; transition:opacity .2s;
}
#killmsg { top:28%; color:#ffcc00; }
#wavemsg { top:38%; color:#ff3300; font-size:clamp(28px,5vw,52px); }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="overlay">
  <h1 class="doom-title">VLAAI DOOM</h1>
  <h2 class="doom-sub">ğŸ¤– ROBOT MASSACRE ğŸ¥§</h2>
  <p class="doom-info">ZQSD / WASD / pijltjes = bewegen &nbsp;|&nbsp; Muis = richten &nbsp;|&nbsp; Klik = schieten</p>
  <p class="doom-info">Klik op het spel voor muisvergrendeling</p>
  <button class="doom-btn" onclick="startGame()">â–¶ SPELEN</button>
</div>

<div id="gameover">
  <h1 class="doom-title" style="color:#ff0000">ğŸ’€ GAME OVER ğŸ’€</h1>
  <p style="font-size:28px;color:#ffaa00;margin:8px 0">Score: <span id="finalScore"></span></p>
  <div id="nameEntry" style="margin:10px 0;display:flex;gap:8px;align-items:center">
    <input id="playerName" maxlength="20" placeholder="Jouw naam..."
      style="padding:8px 14px;font-size:18px;background:#111;color:#ffcc00;border:2px solid #ff4400;border-radius:3px;font-family:monospace;width:200px"
      onkeydown="if(event.key==='Enter')submitScore()">
    <button class="doom-btn" style="margin:0;padding:8px 18px;font-size:16px" onclick="submitScore()">ğŸ’¾ OPSLAAN</button>
  </div>
  <div id="scoreMsg" style="font-size:13px;color:#aaa;min-height:18px;margin-bottom:6px"></div>
  <div id="scoreboard" style="background:rgba(0,0,0,0.7);border:1px solid #333;border-radius:4px;padding:8px 16px;min-width:320px;max-height:220px;overflow-y:auto;margin-bottom:10px">
    <div style="color:#ff6600;font-size:13px;letter-spacing:2px;margin-bottom:6px">ğŸ† SCOREBORD</div>
    <div id="scoreList" style="font-family:monospace;font-size:14px;color:#ccc"></div>
  </div>
  <button class="doom-btn" onclick="startGame()">ğŸ”„ OPNIEUW</button>
</div>

<div id="hud">
  <div class="hud-panel"><div class="hud-lbl">â¤ HP</div><div class="hud-val" id="hHp">100</div></div>
  <div class="hud-panel"><div id="hud-face"></div></div>
  <div class="hud-panel"><div class="hud-lbl">ğŸ† SCORE</div><div class="hud-val" id="hScore">0</div></div>
  <div class="hud-panel"><div class="hud-lbl">ğŸ¥§ VLAAI</div><div class="hud-val">âˆ</div></div>
  <div class="hud-panel"><div class="hud-lbl">ğŸŒŠ GOLF</div><div class="hud-val" id="hWave">1</div></div>
</div>

<div id="killmsg"></div>
<div id="wavemsg"></div>

<script>
'use strict';

// â”€â”€ Web Audio API sound system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
function getAudio() {
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  return audioCtx;
}

// Short noise burst â†’ shoot sound
function sndShoot() {
  const ac=getAudio();
  const buf=ac.createBuffer(1,ac.sampleRate*0.12,ac.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,2.5);
  const src=ac.createBufferSource(); src.buffer=buf;
  const g=ac.createGain(); g.gain.setValueAtTime(0.32,ac.currentTime);
  const f=ac.createBiquadFilter(); f.type='bandpass'; f.frequency.value=900; f.Q.value=1.2;
  src.connect(f); f.connect(g); g.connect(ac.destination);
  src.start(); src.stop(ac.currentTime+0.12);
}

// Punch thud â†’ robot hit
function sndHit() {
  const ac=getAudio();
  const osc=ac.createOscillator(); osc.type='sine';
  osc.frequency.setValueAtTime(180,ac.currentTime);
  osc.frequency.exponentialRampToValueAtTime(60,ac.currentTime+0.08);
  const g=ac.createGain(); g.gain.setValueAtTime(0.5,ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,ac.currentTime+0.1);
  osc.connect(g); g.connect(ac.destination);
  osc.start(); osc.stop(ac.currentTime+0.1);
  // click layer
  const buf=ac.createBuffer(1,ac.sampleRate*0.04,ac.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.5)*0.4;
  const ns=ac.createBufferSource(); ns.buffer=buf;
  const ng=ac.createGain(); ng.gain.value=0.3;
  ns.connect(ng); ng.connect(ac.destination); ns.start();
}

// Explosion rumble â†’ robot death
function sndDeath() {
  const ac=getAudio();
  // noise explosion
  const dur=0.55;
  const buf=ac.createBuffer(1,ac.sampleRate*dur,ac.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.2);
  const src=ac.createBufferSource(); src.buffer=buf;
  const f=ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=280;
  const g=ac.createGain(); g.gain.setValueAtTime(0.7,ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,ac.currentTime+dur);
  src.connect(f); f.connect(g); g.connect(ac.destination); src.start();
  // deep boom
  const osc=ac.createOscillator(); osc.type='sine';
  osc.frequency.setValueAtTime(80,ac.currentTime);
  osc.frequency.exponentialRampToValueAtTime(20,ac.currentTime+0.4);
  const og=ac.createGain(); og.gain.setValueAtTime(0.55,ac.currentTime);
  og.gain.exponentialRampToValueAtTime(0.001,ac.currentTime+0.4);
  osc.connect(og); og.connect(ac.destination); osc.start(); osc.stop(ac.currentTime+0.4);
}

// Player damage yelp
function sndDamage() {
  const ac=getAudio();
  const osc=ac.createOscillator(); osc.type='sawtooth';
  osc.frequency.setValueAtTime(440,ac.currentTime);
  osc.frequency.exponentialRampToValueAtTime(120,ac.currentTime+0.18);
  const g=ac.createGain(); g.gain.setValueAtTime(0.2,ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,ac.currentTime+0.2);
  const f=ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=600;
  osc.connect(f); f.connect(g); g.connect(ac.destination);
  osc.start(); osc.stop(ac.currentTime+0.2);
}

// Wave fanfare
function sndWave() {
  const ac=getAudio();
  const notes=[220,277,330,440];
  notes.forEach((freq,i)=>{
    const osc=ac.createOscillator(); osc.type='square'; osc.frequency.value=freq;
    const g=ac.createGain();
    const t=ac.currentTime+i*0.11;
    g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.18,t+0.03);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.22);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t+0.22);
  });
}

// Ambient drone (low hum, loops)
let ambientNode=null, ambientGain=null;
function startAmbient() {
  const ac=getAudio();
  if(ambientNode) return;
  ambientGain=ac.createGain(); ambientGain.gain.value=0.06;
  // layered drone oscillators
  const freqs=[60,90,120];
  freqs.forEach(freq=>{
    const osc=ac.createOscillator(); osc.type='sawtooth'; osc.frequency.value=freq;
    const g=ac.createGain(); g.gain.value=0.3;
    const f=ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=200;
    osc.connect(f); f.connect(g); g.connect(ambientGain); osc.start();
  });
  ambientGain.connect(ac.destination);
  ambientNode=ambientGain;
}
function stopAmbient() {
  if(ambientGain){ ambientGain.gain.setTargetAtTime(0,getAudio().currentTime,0.5); ambientNode=null; ambientGain=null; }
}

// â”€â”€ Canvas & sizing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');

// Internal render size (classic Doom-ish ratio)
const RW = 640, RH = 400;
canvas.width  = RW;
canvas.height = RH;

let HUD_H = 80; // px of HUD below game

function applyScale() {
  const avW = window.innerWidth;
  const avH = window.innerHeight;
  const s = Math.min(avW / RW, (avH - HUD_H) / RH);
  canvas.style.width  = (RW * s) + 'px';
  canvas.style.height = (RH * s) + 'px';
  canvas.style.position = 'fixed';
  canvas.style.left = ((avW - RW*s)/2) + 'px';
  canvas.style.top  = '0px';
  const hud = document.getElementById('hud');
  hud.style.width = (RW * s) + 'px';
  hud.style.height = HUD_H + 'px';
  hud.style.bottom = '0px';
}
applyScale();
window.addEventListener('resize', applyScale);

// â”€â”€ Map  (0=open, 1-5=wall) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 20Ã—20 open dungeon; robots spawn in corners / edges
const MW = 20, MH = 20;
const MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,2,2,0,0,0,0,0,0,0,0,0,2,2,0,0,0,1],
  [1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,3,3,3,0,0,3,3,3,0,0,0,0,0,1],
  [1,0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,0,0,1],
  [1,0,0,0,0,0,4,4,4,0,0,4,4,4,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,1],
  [1,0,0,5,5,0,0,0,0,0,0,0,0,0,5,5,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

const CELL = 64; // world units per tile

function tileAt(wx, wy) {
  const tx = Math.floor(wx / CELL);
  const ty = Math.floor(wy / CELL);
  if (tx < 0 || tx >= MW || ty < 0 || ty >= MH) return 1;
  return MAP[ty][tx];
}
function walkable(wx, wy) { return tileAt(wx, wy) === 0; }

// â”€â”€ Textures (procedural) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TEX_SIZE = 64;
const TEX = {};

function makeTex(id, fn) {
  const c = document.createElement('canvas');
  c.width = c.height = TEX_SIZE;
  fn(c.getContext('2d'), TEX_SIZE);
  TEX[id] = c;
}

// 1 â€“ brick (brighter warm tones)
makeTex(1, (g,s) => {
  g.fillStyle='#5a4030'; g.fillRect(0,0,s,s);
  const BH=16, BW=32;
  const bc=['#8a5a3a','#7a4a2e','#9a5a32','#6a4028'];
  for(let r=0;r<s/BH;r++){
    for(let c=0;c<s/BW+2;c++){
      const ox=r%2?BW/2:0;
      g.fillStyle=bc[(r+c)%4];
      g.fillRect(c*BW-ox+1,r*BH+1,BW-2,BH-2);
    }
  }
  // highlight top edge of each brick
  g.strokeStyle='rgba(255,200,150,0.15)'; g.lineWidth=1;
  for(let r=0;r<s/BH;r++){
    const ox=r%2?BW/2:0;
    for(let c=0;c<s/BW+2;c++){
      g.beginPath(); g.moveTo(c*BW-ox+1,r*BH+1); g.lineTo(c*BW-ox+BW-2,r*BH+1); g.stroke();
    }
  }
  g.strokeStyle='#281408'; g.lineWidth=1;
  for(let r=0;r<=s/BH;r++){g.beginPath();g.moveTo(0,r*BH);g.lineTo(s,r*BH);g.stroke();}
  for(let r=0;r<s/BH;r++){
    const ox=r%2?BW/2:0;
    for(let c=0;c<=s/BW+2;c++){g.beginPath();g.moveTo(c*BW-ox,r*BH);g.lineTo(c*BW-ox,(r+1)*BH);g.stroke();}
  }
});

// 2 â€“ metal panel (brighter blue-steel)
makeTex(2, (g,s) => {
  g.fillStyle='#2a3a4e'; g.fillRect(0,0,s,s);
  for(let i=0;i<s;i+=8){ g.fillStyle=i%16?'#2e3e52':'#323e58'; g.fillRect(0,i,s,8); }
  g.strokeStyle='#182838'; g.lineWidth=2;
  g.strokeRect(3,3,s-6,s-6);
  for(let r=6;r<s;r+=12) for(let c=6;c<s;c+=12){
    g.beginPath(); g.arc(c,r,2.5,0,Math.PI*2); g.fillStyle='#5a7a8a'; g.fill();
    g.beginPath(); g.arc(c-0.5,r-0.5,1,0,Math.PI*2); g.fillStyle='rgba(200,220,255,0.4)'; g.fill();
  }
  // warning strip
  g.fillStyle='rgba(255,180,0,0.25)';
  for(let i=-s;i<s*2;i+=18){ g.fillRect(i,0,9,s); }
  // horizontal highlight
  g.fillStyle='rgba(150,190,255,0.08)';
  g.fillRect(0,0,s,4);
});

// 3 â€“ mossy stone
makeTex(3, (g,s) => {
  g.fillStyle='#2a3820'; g.fillRect(0,0,s,s);
  const seededRand = (seed) => {
    let x=Math.sin(seed+1)*10000; return x-Math.floor(x);
  };
  for(let i=0;i<180;i++){
    const x=seededRand(i*3)*s, y=seededRand(i*3+1)*s, w=3+seededRand(i*3+2)*6;
    g.fillStyle=`hsl(${110+seededRand(i)*30},${25+seededRand(i+1)*25}%,${18+seededRand(i+2)*12}%)`;
    g.fillRect(x,y,w,w*0.8);
  }
  g.strokeStyle='#111a0a'; g.lineWidth=1;
  for(let r=0;r<s;r+=14){g.beginPath();g.moveTo(0,r);g.lineTo(s,r);g.stroke();}
  for(let c=0;c<s;c+=20){g.beginPath();g.moveTo(c,0);g.lineTo(c,s);g.stroke();}
});

// 4 â€“ red hell wall (brighter, more visible)
makeTex(4, (g,s) => {
  g.fillStyle='#3a0808'; g.fillRect(0,0,s,s);
  for(let i=0;i<s;i+=4){ g.fillStyle=i%8?'#3e0808':'#480a0a'; g.fillRect(0,i,s,4); }
  g.fillStyle='rgba(255,0,0,0.12)'; g.fillRect(0,0,s,s);
  g.fillStyle='rgba(220,90,0,0.28)';
  for(let i=-s;i<s*2;i+=18){ g.fillRect(i,0,9,s); }
  g.strokeStyle='rgba(255,80,20,0.55)'; g.lineWidth=2;
  g.beginPath(); g.moveTo(s/2,4); g.lineTo(s-4,s-4); g.lineTo(4,s-4); g.closePath(); g.stroke();
  // glowing cracks
  g.strokeStyle='rgba(255,120,0,0.3)'; g.lineWidth=1;
  g.beginPath(); g.moveTo(10,10); g.lineTo(25,30); g.lineTo(18,50); g.stroke();
  g.beginPath(); g.moveTo(45,5); g.lineTo(55,22); g.stroke();
});

// 5 â€“ tech / circuit
makeTex(5, (g,s) => {
  g.fillStyle='#070e18'; g.fillRect(0,0,s,s);
  g.strokeStyle='#0a3060'; g.lineWidth=1;
  for(let i=0;i<s;i+=16){
    g.beginPath();g.moveTo(i,0);g.lineTo(i,s);g.stroke();
    g.beginPath();g.moveTo(0,i);g.lineTo(s,i);g.stroke();
  }
  const seededRand2 = (seed) => { let x=Math.sin(seed+99)*10000; return x-Math.floor(x); };
  for(let i=0;i<12;i++){
    const cx=8+seededRand2(i*2)*48, cy=8+seededRand2(i*2+1)*48;
    const gr=g.createRadialGradient(cx,cy,0,cx,cy,6);
    gr.addColorStop(0,'rgba(0,200,255,0.9)'); gr.addColorStop(1,'transparent');
    g.fillStyle=gr; g.beginPath(); g.arc(cx,cy,5,0,Math.PI*2); g.fill();
  }
});

// â”€â”€ Robot sprites â€“ 4 distinct variants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ROB_SZ = 128;

// Variant 0: SCOUT â€“ slim, fast, green eyes, angular
function makeScout(hit) {
  const c=document.createElement('canvas'); c.width=c.height=ROB_SZ;
  const g=c.getContext('2d'), s=ROB_SZ, cx=s/2;
  // thin legs
  g.strokeStyle='#1a3020'; g.lineWidth=s*0.06; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.08,s*0.72); g.lineTo(cx-s*0.1,s*0.95); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.08,s*0.72); g.lineTo(cx+s*0.1,s*0.95); g.stroke();
  // feet
  for(const lx of [-1,1]){ g.fillStyle='#0a1a10'; g.beginPath(); g.ellipse(cx+lx*s*0.1,s*0.95,s*0.07,s*0.03,0,0,Math.PI*2); g.fill(); }
  // slim body
  const bg=g.createLinearGradient(cx,s*0.38,cx,s*0.72);
  bg.addColorStop(0,'#1a4028'); bg.addColorStop(1,'#0a2018');
  g.fillStyle=bg; g.beginPath(); g.roundRect(cx-s*0.16,s*0.38,s*0.32,s*0.34,s*0.03); g.fill();
  g.strokeStyle='#2a8040'; g.lineWidth=1.5; g.stroke();
  // chest scanner
  const cl=g.createRadialGradient(cx,s*0.52,0,cx,s*0.52,s*0.06);
  cl.addColorStop(0,'#00ff80'); cl.addColorStop(1,'rgba(0,200,60,0)');
  g.fillStyle=cl; g.beginPath(); g.arc(cx,s*0.52,s*0.06,0,Math.PI*2); g.fill();
  // thin arms angled downward aggressively
  g.strokeStyle='#1a4028'; g.lineWidth=s*0.06; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.16,s*0.42); g.lineTo(cx-s*0.35,s*0.72); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.16,s*0.42); g.lineTo(cx+s*0.35,s*0.72); g.stroke();
  // bladed claws
  g.strokeStyle='#60ff80'; g.lineWidth=s*0.035;
  for(const lx of [-1,1]) for(const f of [-1,0,1]){
    const ax=cx+lx*s*0.35, ay=s*0.72;
    g.beginPath(); g.moveTo(ax,ay); g.lineTo(ax+lx*s*0.06+f*s*0.04,ay+s*0.1); g.stroke();
  }
  // angular head
  const hg=g.createLinearGradient(cx,s*0.06,cx,s*0.36);
  hg.addColorStop(0,'#1a4028'); hg.addColorStop(1,'#0a2010');
  g.fillStyle=hg;
  g.beginPath(); g.moveTo(cx,s*0.06); g.lineTo(cx+s*0.16,s*0.14); g.lineTo(cx+s*0.14,s*0.36); g.lineTo(cx-s*0.14,s*0.36); g.lineTo(cx-s*0.16,s*0.14); g.closePath(); g.fill();
  g.strokeStyle='#40c060'; g.lineWidth=1.5; g.stroke();
  // single visor slit
  g.fillStyle='#001a08'; g.fillRect(cx-s*0.12,s*0.17,s*0.24,s*0.07);
  // green eyes
  for(const ex of [-1,1]){
    const eg=g.createRadialGradient(cx+ex*s*0.06,s*0.205,0,cx+ex*s*0.06,s*0.205,s*0.05);
    eg.addColorStop(0,'#00ff80'); eg.addColorStop(0.5,'#00aa40'); eg.addColorStop(1,'rgba(0,100,30,0)');
    g.fillStyle=eg; g.beginPath(); g.arc(cx+ex*s*0.06,s*0.205,s*0.05,0,Math.PI*2); g.fill();
  }
  // antennae (2 thin ones)
  g.strokeStyle='#40c060'; g.lineWidth=1.5;
  g.beginPath(); g.moveTo(cx-s*0.05,s*0.06); g.lineTo(cx-s*0.1,s*0.0); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.05,s*0.06); g.lineTo(cx+s*0.1,s*0.0); g.stroke();
  g.fillStyle='#00ff80';
  g.beginPath(); g.arc(cx-s*0.1,s*0.0,s*0.018,0,Math.PI*2); g.fill();
  g.beginPath(); g.arc(cx+s*0.1,s*0.0,s*0.018,0,Math.PI*2); g.fill();
  if(hit){ g.globalCompositeOperation='source-atop'; g.fillStyle='rgba(255,120,0,0.7)'; g.fillRect(0,0,s,s); }
  return c;
}

// Variant 1: GRUNT â€“ standard soldier bot, red eyes, blocky
function makeGrunt(hit) {
  const c=document.createElement('canvas'); c.width=c.height=ROB_SZ;
  const g=c.getContext('2d'), s=ROB_SZ, cx=s/2;
  g.strokeStyle='#2a3a4a'; g.lineWidth=s*0.09; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.12,s*0.74); g.lineTo(cx-s*0.13,s*0.93); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.12,s*0.74); g.lineTo(cx+s*0.13,s*0.93); g.stroke();
  for(const lx of [-1,1]){ g.fillStyle='#1a2a38'; g.beginPath(); g.ellipse(cx+lx*s*0.13,s*0.93,s*0.09,s*0.04,0,0,Math.PI*2); g.fill(); }
  const bg=g.createLinearGradient(cx-s*0.23,s*0.38,cx+s*0.23,s*0.72);
  bg.addColorStop(0,'#4a6070'); bg.addColorStop(1,'#1e2e3e');
  g.fillStyle=bg; g.fillRect(cx-s*0.23,s*0.38,s*0.46,s*0.36);
  g.strokeStyle='#6090aa'; g.lineWidth=1.5; g.strokeRect(cx-s*0.23,s*0.38,s*0.46,s*0.36);
  const cl=g.createRadialGradient(cx,s*0.52,0,cx,s*0.52,s*0.07);
  cl.addColorStop(0,'#00eeff'); cl.addColorStop(1,'rgba(0,120,200,0)');
  g.fillStyle=cl; g.beginPath(); g.arc(cx,s*0.52,s*0.07,0,Math.PI*2); g.fill();
  g.strokeStyle='#2a3a4a'; g.lineWidth=s*0.09; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.23,s*0.44); g.lineTo(cx-s*0.38,s*0.62); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.23,s*0.44); g.lineTo(cx+s*0.38,s*0.62); g.stroke();
  g.strokeStyle='#4a8a9a'; g.lineWidth=s*0.04;
  for(const lx of [-1,1]) for(const f of [-1,0,1]){
    const ax=cx+lx*s*0.38, ay=s*0.62;
    g.beginPath(); g.moveTo(ax,ay); g.lineTo(ax+lx*s*0.05+f*s*0.03,ay+s*0.07); g.stroke();
  }
  const hg=g.createLinearGradient(cx-s*0.18,s*0.09,cx+s*0.18,s*0.34);
  hg.addColorStop(0,'#5a6a7a'); hg.addColorStop(1,'#2a3a4a');
  g.fillStyle=hg; g.fillRect(cx-s*0.18,s*0.09,s*0.36,s*0.28);
  g.strokeStyle='#8ab0cc'; g.lineWidth=1.5; g.strokeRect(cx-s*0.18,s*0.09,s*0.36,s*0.28);
  const vg=g.createLinearGradient(cx-s*0.15,s*0.14,cx+s*0.15,s*0.28);
  vg.addColorStop(0,'#0a2030'); vg.addColorStop(1,'#041018');
  g.fillStyle=vg; g.fillRect(cx-s*0.15,s*0.14,s*0.3,s*0.12);
  for(const ex of [-1,1]){
    const eg=g.createRadialGradient(cx+ex*s*0.08,s*0.19,0,cx+ex*s*0.08,s*0.19,s*0.055);
    eg.addColorStop(0,'#ff5500'); eg.addColorStop(0.6,'#bb1100'); eg.addColorStop(1,'rgba(100,0,0,0)');
    g.fillStyle=eg; g.beginPath(); g.arc(cx+ex*s*0.08,s*0.19,s*0.055,0,Math.PI*2); g.fill();
  }
  g.strokeStyle='#8ab0cc'; g.lineWidth=2;
  g.beginPath(); g.moveTo(cx,s*0.09); g.lineTo(cx,s*0.02); g.stroke();
  g.fillStyle='#ff2200'; g.beginPath(); g.arc(cx,s*0.02,s*0.022,0,Math.PI*2); g.fill();
  if(hit){ g.globalCompositeOperation='source-atop'; g.fillStyle='rgba(255,80,0,0.65)'; g.fillRect(0,0,s,s); }
  return c;
}

// Variant 2: HEAVY â€“ large armored tank bot, orange eyes, shoulder cannons
function makeHeavy(hit) {
  const c=document.createElement('canvas'); c.width=c.height=ROB_SZ;
  const g=c.getContext('2d'), s=ROB_SZ, cx=s/2;
  // thick legs
  g.strokeStyle='#3a2010'; g.lineWidth=s*0.14; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.15,s*0.72); g.lineTo(cx-s*0.16,s*0.92); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.15,s*0.72); g.lineTo(cx+s*0.16,s*0.92); g.stroke();
  for(const lx of [-1,1]){ g.fillStyle='#1a0e06'; g.beginPath(); g.ellipse(cx+lx*s*0.16,s*0.92,s*0.13,s*0.055,0,0,Math.PI*2); g.fill(); }
  // big armored body
  const bg=g.createLinearGradient(cx,s*0.32,cx,s*0.74);
  bg.addColorStop(0,'#7a4820'); bg.addColorStop(0.5,'#5a3010'); bg.addColorStop(1,'#3a1808');
  g.fillStyle=bg; g.beginPath(); g.roundRect(cx-s*0.29,s*0.34,s*0.58,s*0.38,s*0.03); g.fill();
  g.strokeStyle='#ff6000'; g.lineWidth=2; g.stroke();
  // armor plating lines
  g.strokeStyle='rgba(255,120,0,0.4)'; g.lineWidth=1;
  g.beginPath(); g.moveTo(cx-s*0.29,s*0.48); g.lineTo(cx+s*0.29,s*0.48); g.stroke();
  g.beginPath(); g.moveTo(cx-s*0.29,s*0.60); g.lineTo(cx+s*0.29,s*0.60); g.stroke();
  // chest reactor glow
  const cl=g.createRadialGradient(cx,s*0.52,0,cx,s*0.52,s*0.1);
  cl.addColorStop(0,'#ffaa00'); cl.addColorStop(0.4,'#ff4400'); cl.addColorStop(1,'rgba(200,60,0,0)');
  g.fillStyle=cl; g.beginPath(); g.arc(cx,s*0.52,s*0.1,0,Math.PI*2); g.fill();
  // shoulder cannons
  for(const lx of [-1,1]){
    g.fillStyle='#4a2808'; g.beginPath(); g.roundRect(cx+lx*s*0.28,s*0.34,lx*s*0.12,s*0.14,3); g.fill();
    g.strokeStyle='#ff6000'; g.lineWidth=1.5; g.stroke();
    g.fillStyle='#1a0800'; g.beginPath(); g.arc(cx+lx*s*0.40,s*0.40,s*0.04,0,Math.PI*2); g.fill();
    g.strokeStyle='#ff8800'; g.lineWidth=1; g.stroke();
  }
  // arms (huge)
  g.strokeStyle='#4a2810'; g.lineWidth=s*0.13; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.28,s*0.44); g.lineTo(cx-s*0.44,s*0.66); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.28,s*0.44); g.lineTo(cx+s*0.44,s*0.66); g.stroke();
  // crushing fists
  for(const lx of [-1,1]){
    const fx=cx+lx*s*0.44, fy=s*0.66;
    g.fillStyle='#3a1808'; g.beginPath(); g.roundRect(fx-s*0.08,fy-s*0.06,s*0.16,s*0.14,4); g.fill();
    g.strokeStyle='#ff6000'; g.lineWidth=1.5; g.stroke();
  }
  // heavy square head
  const hg=g.createLinearGradient(cx,s*0.07,cx,s*0.34);
  hg.addColorStop(0,'#6a3818'); hg.addColorStop(1,'#3a1a08');
  g.fillStyle=hg; g.beginPath(); g.roundRect(cx-s*0.22,s*0.07,s*0.44,s*0.27,s*0.02); g.fill();
  g.strokeStyle='#ff6000'; g.lineWidth=2; g.stroke();
  // armored brow ridge
  g.fillStyle='#4a2208'; g.beginPath(); g.roundRect(cx-s*0.22,s*0.07,s*0.44,s*0.07,s*0.02); g.fill();
  g.strokeStyle='#ff8800'; g.lineWidth=1; g.stroke();
  // orange eyes (wider, angrier)
  for(const ex of [-1,1]){
    const eg=g.createRadialGradient(cx+ex*s*0.09,s*0.21,0,cx+ex*s*0.09,s*0.21,s*0.065);
    eg.addColorStop(0,'#ffaa00'); eg.addColorStop(0.5,'#ff5500'); eg.addColorStop(1,'rgba(180,60,0,0)');
    g.fillStyle=eg; g.beginPath(); g.arc(cx+ex*s*0.09,s*0.21,s*0.065,0,Math.PI*2); g.fill();
  }
  // spike on top of head
  g.fillStyle='#ff6000';
  g.beginPath(); g.moveTo(cx,s*0.07); g.lineTo(cx-s*0.04,s*0.0); g.lineTo(cx+s*0.04,s*0.0); g.closePath(); g.fill();
  if(hit){ g.globalCompositeOperation='source-atop'; g.fillStyle='rgba(255,80,0,0.65)'; g.fillRect(0,0,s,s); }
  return c;
}

// Variant 3: BOSS â€“ massive, purple/dark, multiple spikes, glowing eyes, wings
function makeBoss(hit) {
  const c=document.createElement('canvas'); c.width=c.height=ROB_SZ;
  const g=c.getContext('2d'), s=ROB_SZ, cx=s/2;
  // wing-like shoulder extensions
  for(const lx of [-1,1]){
    g.fillStyle='#1a0030';
    g.beginPath(); g.moveTo(cx+lx*s*0.22,s*0.25); g.lineTo(cx+lx*s*0.50,s*0.10); g.lineTo(cx+lx*s*0.48,s*0.50); g.closePath(); g.fill();
    g.strokeStyle='#aa00ff'; g.lineWidth=1.5; g.stroke();
    // vein glow on wing
    g.strokeStyle='rgba(160,0,255,0.4)'; g.lineWidth=1;
    g.beginPath(); g.moveTo(cx+lx*s*0.25,s*0.3); g.lineTo(cx+lx*s*0.45,s*0.18); g.stroke();
    g.beginPath(); g.moveTo(cx+lx*s*0.26,s*0.35); g.lineTo(cx+lx*s*0.44,s*0.38); g.stroke();
  }
  // thick legs
  g.strokeStyle='#1a0030'; g.lineWidth=s*0.12; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.14,s*0.74); g.lineTo(cx-s*0.16,s*0.94); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.14,s*0.74); g.lineTo(cx+s*0.16,s*0.94); g.stroke();
  for(const lx of [-1,1]){ g.fillStyle='#0a0018'; g.beginPath(); g.ellipse(cx+lx*s*0.16,s*0.94,s*0.11,s*0.05,0,0,Math.PI*2); g.fill(); }
  // body
  const bg=g.createLinearGradient(cx,s*0.32,cx,s*0.74);
  bg.addColorStop(0,'#3a0060'); bg.addColorStop(0.5,'#220040'); bg.addColorStop(1,'#100020');
  g.fillStyle=bg; g.beginPath(); g.roundRect(cx-s*0.26,s*0.34,s*0.52,s*0.40,s*0.03); g.fill();
  g.strokeStyle='#cc00ff'; g.lineWidth=2; g.stroke();
  // body runes/cracks glowing
  g.strokeStyle='rgba(180,0,255,0.5)'; g.lineWidth=1.5;
  g.beginPath(); g.moveTo(cx-s*0.18,s*0.42); g.lineTo(cx-s*0.08,s*0.5); g.lineTo(cx-s*0.14,s*0.6); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.18,s*0.42); g.lineTo(cx+s*0.08,s*0.5); g.lineTo(cx+s*0.14,s*0.6); g.stroke();
  // dark core eye
  const cl=g.createRadialGradient(cx,s*0.52,0,cx,s*0.52,s*0.1);
  cl.addColorStop(0,'#ffffff'); cl.addColorStop(0.2,'#cc00ff'); cl.addColorStop(0.7,'#440088'); cl.addColorStop(1,'rgba(40,0,80,0)');
  g.fillStyle=cl; g.beginPath(); g.arc(cx,s*0.52,s*0.1,0,Math.PI*2); g.fill();
  // arms with spikes
  g.strokeStyle='#2a0050'; g.lineWidth=s*0.11; g.lineCap='round';
  g.beginPath(); g.moveTo(cx-s*0.26,s*0.42); g.lineTo(cx-s*0.42,s*0.65); g.stroke();
  g.beginPath(); g.moveTo(cx+s*0.26,s*0.42); g.lineTo(cx+s*0.42,s*0.65); g.stroke();
  // claw fingers (5 per hand, long)
  g.strokeStyle='#ee00ff'; g.lineWidth=s*0.035;
  for(const lx of [-1,1]) for(let f=-2;f<=2;f++){
    const ax=cx+lx*s*0.42, ay=s*0.65;
    g.beginPath(); g.moveTo(ax,ay); g.lineTo(ax+lx*s*0.06+f*s*0.032,ay+s*0.12); g.stroke();
  }
  // large angular head
  const hg=g.createLinearGradient(cx,s*0.04,cx,s*0.34);
  hg.addColorStop(0,'#2a0050'); hg.addColorStop(1,'#100020');
  g.fillStyle=hg;
  g.beginPath(); g.moveTo(cx,s*0.02); g.lineTo(cx+s*0.22,s*0.1); g.lineTo(cx+s*0.2,s*0.34); g.lineTo(cx-s*0.2,s*0.34); g.lineTo(cx-s*0.22,s*0.1); g.closePath(); g.fill();
  g.strokeStyle='#cc00ff'; g.lineWidth=2; g.stroke();
  // 3 head spikes
  g.fillStyle='#aa00ff';
  for(const sx of [-0.12,0,0.12]){
    g.beginPath(); g.moveTo(cx+sx*s,s*0.02); g.lineTo(cx+sx*s-s*0.03,s*0.1); g.lineTo(cx+sx*s+s*0.03,s*0.1); g.closePath(); g.fill();
  }
  // visor
  g.fillStyle='#000010'; g.beginPath(); g.roundRect(cx-s*0.17,s*0.14,s*0.34,s*0.1,3); g.fill();
  // glowing purple eyes (4 of them!)
  const eyeY=s*0.18;
  for(const ex of [-0.13,-0.04,0.04,0.13]){
    const eg=g.createRadialGradient(cx+ex*s,eyeY,0,cx+ex*s,eyeY,s*0.045);
    eg.addColorStop(0,'#ffffff'); eg.addColorStop(0.3,'#ee00ff'); eg.addColorStop(1,'rgba(100,0,180,0)');
    g.fillStyle=eg; g.beginPath(); g.arc(cx+ex*s,eyeY,s*0.045,0,Math.PI*2); g.fill();
  }
  // evil grin
  g.strokeStyle='rgba(200,0,255,0.6)'; g.lineWidth=1.5;
  g.beginPath(); g.moveTo(cx-s*0.1,s*0.28); g.quadraticCurveTo(cx,s*0.33,cx+s*0.1,s*0.28); g.stroke();
  // teeth
  g.fillStyle='rgba(220,0,255,0.5)';
  for(let t=-2;t<=2;t++){ g.beginPath(); g.moveTo(cx+t*s*0.04,s*0.28); g.lineTo(cx+t*s*0.04-s*0.015,s*0.32); g.lineTo(cx+t*s*0.04+s*0.015,s*0.32); g.closePath(); g.fill(); }
  if(hit){ g.globalCompositeOperation='source-atop'; g.fillStyle='rgba(255,80,0,0.65)'; g.fillRect(0,0,s,s); }
  return c;
}

// Pre-render all 4 Ã— 2 (normal + hit) variants
const ROB_VARIANTS = [
  [makeScout(false), makeScout(true)],   // 0: Scout  (waves 1-2)
  [makeGrunt(false), makeGrunt(true)],   // 1: Grunt  (waves 2-4)
  [makeHeavy(false), makeHeavy(true)],   // 2: Heavy  (waves 4-6)
  [makeBoss(false),  makeBoss(true)],    // 3: Boss   (waves 6+)
];
// Helper: which variant index for a given wave
function robotVariant(w) {
  if(w<=2)  return 0; // scout
  if(w<=4)  return 1; // grunt
  if(w<=6)  return 2; // heavy
  return 3;           // boss
}

// â”€â”€ Vlaai sprite â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const VLAAI_C = document.createElement('canvas');
VLAAI_C.width = VLAAI_C.height = 64;
(function(){
  const g=VLAAI_C.getContext('2d'), s=64, cx=s/2, cy=s/2, r=s/2-2;
  const crust=g.createRadialGradient(cx,cy,r*0.35,cx,cy,r);
  crust.addColorStop(0,'#d4a040'); crust.addColorStop(1,'#7a3a10');
  g.fillStyle=crust; g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();
  g.strokeStyle='#5a2808'; g.lineWidth=2; g.stroke();
  const fill=g.createRadialGradient(cx-r*0.1,cy-r*0.1,0,cx,cy,r*0.76);
  fill.addColorStop(0,'#cc2020'); fill.addColorStop(1,'#881010');
  g.fillStyle=fill; g.beginPath(); g.arc(cx,cy,r*0.76,0,Math.PI*2); g.fill();
  g.fillStyle='rgba(255,180,180,0.35)'; g.beginPath(); g.arc(cx-r*0.22,cy-r*0.22,r*0.2,0,Math.PI*2); g.fill();
  for(let i=0;i<3;i++){
    const a=i*Math.PI*2/3+0.4;
    g.fillStyle='#880000';
    g.beginPath(); g.arc(cx+Math.cos(a)*r*0.3,cy+Math.sin(a)*r*0.3,r*0.1,0,Math.PI*2); g.fill();
    g.fillStyle='rgba(255,180,180,0.5)';
    g.beginPath(); g.arc(cx+Math.cos(a)*r*0.3-r*0.04,cy+Math.sin(a)*r*0.3-r*0.04,r*0.04,0,Math.PI*2); g.fill();
  }
})();

// â”€â”€ Player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const P = {
  x: 2*CELL+CELL/2,
  y: 2*CELL+CELL/2,
  angle: 0.5,
  hp: 100,
  score: 0,
  bob: 0,
  bobT: 0,
  shootCD: 0,
  recoil: 0,
  RADIUS: 14,   // collision radius in world units
  SPEED:  2.5,  // world units per frame
  ROT:    0.04, // rad per frame
};

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let robots=[], bullets=[], particles=[];
let wave=1, waveTimer=0;
let running=false;
let dmgFlash=0, hitRed=0;
let killMsgT=0, waveMsgT=0;

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const K = {};
document.addEventListener('keydown', e=>{ K[e.code]=true; e.preventDefault && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code) && e.preventDefault(); });
document.addEventListener('keyup',   e=>{ K[e.code]=false; });

let mouseDX = 0;
document.addEventListener('mousemove', e=>{
  if(document.pointerLockElement === canvas) mouseDX += e.movementX;
});
canvas.addEventListener('click', ()=>{ canvas.requestPointerLock(); });
document.addEventListener('mousedown', e=>{ if(running && e.button===0) shoot(); });

// â”€â”€ Raycaster â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pure DDA â€“ returns { dist (world units, already perp-corrected), wallTex, wallU, side }
function castRay(px, py, angle) {
  const dx = Math.cos(angle);
  const dy = Math.sin(angle);

  let mapX = Math.floor(px/CELL);
  let mapY = Math.floor(py/CELL);

  const dDX = Math.abs(1/dx);
  const dDY = Math.abs(1/dy);

  let stepX, stepY, sideDistX, sideDistY;
  if(dx < 0){ stepX=-1; sideDistX=(px/CELL-mapX)*dDX; }
  else       { stepX= 1; sideDistX=(mapX+1-px/CELL)*dDX; }
  if(dy < 0){ stepY=-1; sideDistY=(py/CELL-mapY)*dDY; }
  else       { stepY= 1; sideDistY=(mapY+1-py/CELL)*dDY; }

  let side=0, wallTex=0;
  for(let i=0;i<100;i++){
    if(sideDistX < sideDistY){ sideDistX+=dDX; mapX+=stepX; side=0; }
    else                      { sideDistY+=dDY; mapY+=stepY; side=1; }
    if(mapX<0||mapX>=MW||mapY<0||mapY>=MH){ wallTex=1; break; }
    wallTex = MAP[mapY][mapX];
    if(wallTex>0) break;
  }

  let perpDist, wallU;
  if(side===0){ perpDist=(mapX - px/CELL + (1-stepX)/2)/dx; wallU=py/CELL+perpDist*dy; }
  else        { perpDist=(mapY - py/CELL + (1-stepY)/2)/dy; wallU=px/CELL+perpDist*dx; }
  wallU -= Math.floor(wallU);

  return { dist: perpDist*CELL, wallTex, wallU, side };
}

// â”€â”€ Raycaster rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const NUM_RAYS = RW; // one ray per pixel column for clean rendering
const FOCAL    = RW / (2*Math.tan(Math.PI/3/2)); // projection plane distance
const zBuf     = new Float32Array(NUM_RAYS);

function renderWalls(bob) {
  const halfH = RH/2 + bob;

  // Ceiling â€“ bright lavender/sky, much lighter
  const ceilG = ctx.createLinearGradient(0,0,0,halfH);
  ceilG.addColorStop(0,'#6a5a8a'); ceilG.addColorStop(1,'#8a7aaa');
  ctx.fillStyle=ceilG; ctx.fillRect(0,0,RW,halfH);

  // Floor â€“ warm stone, bright sandy brown
  const fg=ctx.createLinearGradient(0,halfH,0,RH);
  fg.addColorStop(0,'#9a8060'); fg.addColorStop(1,'#6a5840');
  ctx.fillStyle=fg; ctx.fillRect(0,halfH,RW,RH-halfH);

  for(let col=0; col<NUM_RAYS; col++){
    const rayAngle = P.angle - Math.PI/6 + (Math.PI/3)*(col/NUM_RAYS);
    const {dist, wallTex, wallU, side} = castRay(P.x, P.y, rayAngle);

    zBuf[col] = dist;

    if(!wallTex) continue;

    const wallH    = Math.min(RH*5, (CELL/dist)*FOCAL);
    const wallTop  = Math.max(0, halfH - wallH/2);
    const wallBot  = Math.min(RH, halfH + wallH/2);
    const drawH    = wallBot - wallTop;

    const tex = TEX[wallTex];
    if(!tex) continue;

    const texCol = Math.floor(wallU * TEX_SIZE);

    // Much brighter â€“ fog starts far away, max darkness only 0.42
    const fogAmt  = Math.min(1, dist/(CELL*18));
    const sideShd = side ? 0.78 : 1.0;
    const darkness = Math.min(0.42, 1 - sideShd*(1-fogAmt*0.55));

    ctx.drawImage(tex, texCol,0,1,TEX_SIZE, col, wallTop, 1, drawH);
    if(darkness > 0.02){
      ctx.fillStyle = `rgba(0,0,0,${darkness.toFixed(2)})`;
      ctx.fillRect(col, wallTop, 1, drawH);
    }
  }
}

// â”€â”€ Sprite rendering (billboard) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSprites(bob) {
  const halfH = RH/2 + bob;

  // Transform sprites to camera space
  const camDirX = Math.cos(P.angle), camDirY = Math.sin(P.angle);
  const planeX  = -Math.sin(P.angle)*Math.tan(Math.PI/6);
  const planeY  =  Math.cos(P.angle)*Math.tan(Math.PI/6);

  const sprs = [];
  for(const r of robots){
    if(r.dead&&r.deathT>25) continue;
    const rx=r.x-P.x, ry=r.y-P.y;
    sprs.push({kind:'robot',obj:r, rx,ry, dist2:rx*rx+ry*ry});
  }
  for(const b of bullets){
    const rx=b.x-P.x, ry=b.y-P.y;
    sprs.push({kind:'bullet',obj:b, rx,ry, dist2:rx*rx+ry*ry});
  }
  sprs.sort((a,b)=>b.dist2-a.dist2);

  for(const sp of sprs){
    const {rx,ry} = sp;
    const invDet = 1/(planeX*camDirY - camDirX*planeY);
    const tX = invDet*(camDirY*rx - camDirX*ry);
    const tY = invDet*(-planeY*rx + planeX*ry);
    if(tY<=0.05) continue;

    const screenX = Math.floor((RW/2)*(1+tX/tY));

    if(sp.kind==='robot'){
      const r=sp.obj;
      const sc=r.sizeScale??1.0;
      const h = Math.floor(Math.min(RH*3, (CELL*sc/tY)*FOCAL));
      const w = h;
      const x0=screenX-w/2, y0=halfH-h*0.55;
      // per-column Z clipping
      let anyVis=false;
      const col0=Math.max(0,Math.floor(x0)), col1=Math.min(RW-1,Math.floor(x0+w));
      for(let c=col0;c<=col1;c+=3){ if(tY<zBuf[c]){anyVis=true;break;} }
      if(!anyVis) continue;

      const fog=Math.min(0.88,tY/(CELL*9));
      ctx.globalAlpha=Math.max(0,1-fog)*(r.dead?Math.max(0,1-r.deathT/25):1);
      const vp=ROB_VARIANTS[r.variant??1];
      const img = r.hitT>0 ? vp[1] : vp[0];

      // clip to z-buffer column by column
      ctx.save();
      const rgn=new Path2D();
      for(let c=col0;c<=col1;c++){ if(tY<zBuf[c]){ rgn.rect(c,0,1,RH); } }
      ctx.clip(rgn);
      ctx.drawImage(img, x0, y0, w, h);
      ctx.restore();

      // hp bar
      if(r.maxHp>1&&tY<CELL*5){
        const bw=w*0.75, bx=screenX-bw/2, by=y0-8;
        ctx.fillStyle='#1a0000'; ctx.fillRect(bx,by,bw,5);
        ctx.fillStyle=r.hp/r.maxHp>0.5?'#44ff44':r.hp/r.maxHp>0.25?'#ffaa00':'#ff2200';
        ctx.fillRect(bx,by,bw*(r.hp/r.maxHp),5);
      }
      ctx.globalAlpha=1;

    } else {
      // bullet â€“ vlaai SLICE spinning through air
      const h=Math.min(120,Math.floor((CELL*0.55/tY)*FOCAL));
      if(h<4) continue;
      const col=Math.floor(screenX*NUM_RAYS/RW);
      if(col>=0&&col<NUM_RAYS&&tY>zBuf[col]) continue;
      const b=sp.obj;
      ctx.save();
      ctx.translate(screenX, halfH+h*0.1);
      ctx.rotate(b.rot);
      // â”€â”€ Actual pie WEDGE slice â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const r=h/2;
      const SLICE=Math.PI*0.65; // ~117Â° slice angle
      const half=SLICE/2;
      // glow trail behind
      ctx.globalAlpha=0.4;
      const glowG=ctx.createRadialGradient(0,0,0,0,0,r*1.5);
      glowG.addColorStop(0,'rgba(255,160,0,0.85)'); glowG.addColorStop(1,'rgba(255,80,0,0)');
      ctx.fillStyle=glowG; ctx.beginPath(); ctx.arc(0,0,r*1.5,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
      // crust outer edge (full wedge)
      const crustG=ctx.createRadialGradient(0,0,r*0.5,0,0,r);
      crustG.addColorStop(0,'#c8900a'); crustG.addColorStop(0.7,'#d4a030'); crustG.addColorStop(1,'#7a3a10');
      ctx.fillStyle=crustG;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,r,-half,half);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle='#5a2808'; ctx.lineWidth=1.5; ctx.stroke();
      // cherry filling (inner wedge, slightly smaller)
      const fillG=ctx.createRadialGradient(-r*0.1,-r*0.1,0,0,0,r*0.78);
      fillG.addColorStop(0,'#ee3030'); fillG.addColorStop(1,'#991010');
      ctx.fillStyle=fillG;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,r*0.78,-half,half);
      ctx.closePath();
      ctx.fill();
      // shine highlight
      ctx.fillStyle='rgba(255,200,200,0.35)';
      ctx.beginPath();
      ctx.arc(-r*0.28,-r*0.28,r*0.18,0,Math.PI*2);
      ctx.fill();
      // cherries inside the slice
      for(let ci=0;ci<2;ci++){
        const ca=(ci-0.5)*half*0.8;
        const cr=r*0.42;
        ctx.beginPath(); ctx.arc(Math.cos(ca)*cr,Math.sin(ca)*cr,r*0.11,0,Math.PI*2);
        ctx.fillStyle='#770000'; ctx.fill();
        ctx.fillStyle='rgba(255,160,160,0.5)';
        ctx.beginPath(); ctx.arc(Math.cos(ca)*cr-r*0.04,Math.sin(ca)*cr-r*0.04,r*0.04,0,Math.PI*2); ctx.fill();
      }
      // straight cut-line edges (the two radii of the wedge)
      ctx.strokeStyle='rgba(90,40,10,0.7)'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(-half)*r,Math.sin(-half)*r); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(half)*r,Math.sin(half)*r); ctx.stroke();
      ctx.restore();
    }
  }
}

// â”€â”€ First-person weapon â€“ VLAAI RIFLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Classic Doom style: big rifle, one hand visible bottom-right
// The rifle points LEFT (toward screen center), drawn from the side
function renderWeapon() {
  const recoil = P.recoil * 14;
  const bobY   = Math.sin(P.bobT) * 5;
  const bobX   = Math.cos(P.bobT*0.5) * 2;

  // World anchor: bottom-right quadrant
  const AX = RW - 90 + bobX;
  const AY = RH + 20 + recoil + bobY;

  ctx.save();
  ctx.translate(AX, AY);

  // â”€â”€ Rifle drawn first (behind hand) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.save();
  ctx.translate(-60, -155);
  ctx.rotate(-0.08); // slight upward tilt

  // === STOCK (right end, behind hand) ===
  const stockG = ctx.createLinearGradient(80,-16,80,16);
  stockG.addColorStop(0,'#6a3a18'); stockG.addColorStop(0.5,'#8a5228'); stockG.addColorStop(1,'#4a2810');
  ctx.fillStyle=stockG;
  ctx.beginPath(); ctx.roundRect(50,-14,55,28,4); ctx.fill();
  ctx.strokeStyle='#3a1e08'; ctx.lineWidth=1.5; ctx.stroke();
  // stock cheekpiece curve
  ctx.beginPath();
  ctx.moveTo(50,-14); ctx.bezierCurveTo(60,-20,90,-18,105,-14);
  ctx.lineTo(105,8); ctx.bezierCurveTo(90,8,60,6,50,14); ctx.closePath();
  ctx.fillStyle=stockG; ctx.fill();
  ctx.strokeStyle='#3a1e08'; ctx.lineWidth=1; ctx.stroke();
  // wood grain on stock
  ctx.strokeStyle='rgba(50,20,5,0.3)'; ctx.lineWidth=1;
  for(let wg=0;wg<5;wg++){
    ctx.beginPath(); ctx.moveTo(55,-8+wg*5); ctx.quadraticCurveTo(80,-9+wg*5,100,-7+wg*5); ctx.stroke();
  }

  // === RECEIVER / BODY ===
  const recvG = ctx.createLinearGradient(0,-20,0,20);
  recvG.addColorStop(0,'#c89030'); recvG.addColorStop(0.4,'#e8b840'); recvG.addColorStop(1,'#9a6a18');
  ctx.fillStyle=recvG;
  ctx.beginPath(); ctx.roundRect(-10,-20,65,40,6); ctx.fill();
  ctx.strokeStyle='#7a4810'; ctx.lineWidth=2; ctx.stroke();
  // receiver detail panel
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.beginPath(); ctx.roundRect(-5,-15,55,30,4); ctx.fill();
  // ejection port
  ctx.fillStyle='#2a1208';
  ctx.beginPath(); ctx.roundRect(5,-12,22,10,2); ctx.fill();
  ctx.strokeStyle='#1a0a04'; ctx.lineWidth=1; ctx.stroke();

  // === BARREL (long, extending left) ===
  const barrelG = ctx.createLinearGradient(0,-12,0,12);
  barrelG.addColorStop(0,'#d4a038'); barrelG.addColorStop(0.5,'#f0c050'); barrelG.addColorStop(1,'#a87020');
  ctx.fillStyle=barrelG;
  ctx.beginPath(); ctx.roundRect(-155,-12,150,24,3); ctx.fill();
  ctx.strokeStyle='#7a4810'; ctx.lineWidth=1.5; ctx.stroke();

  // barrel heat ribs
  ctx.strokeStyle='rgba(80,40,0,0.4)'; ctx.lineWidth=2;
  for(let rb=0;rb<10;rb++){
    const bx=-148+rb*14;
    ctx.beginPath(); ctx.moveTo(bx,-12); ctx.lineTo(bx,12); ctx.stroke();
  }

  // === FOREGRIP / HANDGUARD under barrel ===
  const fgG = ctx.createLinearGradient(0,10,0,30);
  fgG.addColorStop(0,'#6a3a18'); fgG.addColorStop(1,'#4a2010');
  ctx.fillStyle=fgG;
  ctx.beginPath(); ctx.roundRect(-120,10,90,20,5); ctx.fill();
  ctx.strokeStyle='#3a1808'; ctx.lineWidth=1; ctx.stroke();
  // foregrip texture
  ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=1;
  for(let fg2=0;fg2<8;fg2++){
    ctx.beginPath(); ctx.moveTo(-115+fg2*11,10); ctx.lineTo(-115+fg2*11,30); ctx.stroke();
  }

  // === RAIL / SCOPE on top ===
  ctx.fillStyle='#4a3010';
  ctx.fillRect(-100,-28,130,10);
  ctx.strokeStyle='#2a1808'; ctx.lineWidth=1; ctx.strokeRect(-100,-28,130,10);
  // rail notches
  ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1;
  for(let rn=0;rn<12;rn++){ ctx.beginPath(); ctx.moveTo(-97+rn*10,-28); ctx.lineTo(-97+rn*10,-18); ctx.stroke(); }

  // scope body
  const scpG = ctx.createLinearGradient(-80,-38,-80,-20);
  scpG.addColorStop(0,'#1a1a1a'); scpG.addColorStop(1,'#3a3a3a');
  ctx.fillStyle=scpG;
  ctx.beginPath(); ctx.roundRect(-82,-38,60,12,4); ctx.fill();
  ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.stroke();
  // scope lenses
  for(const lx of [-80,-24]){
    ctx.beginPath(); ctx.arc(lx,-32,5,0,Math.PI*2);
    ctx.fillStyle='#112233'; ctx.fill();
    ctx.strokeStyle='#334'; ctx.lineWidth=1; ctx.stroke();
    ctx.beginPath(); ctx.arc(lx,-32,3,0,Math.PI*2);
    ctx.fillStyle='rgba(0,180,255,0.35)'; ctx.fill();
    // lens shine
    ctx.beginPath(); ctx.arc(lx-1,-33,1.2,0,Math.PI*2);
    ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.fill();
  }
  // windage knob
  ctx.fillStyle='#222';
  ctx.beginPath(); ctx.ellipse(-52,-22,5,3,0,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#444'; ctx.lineWidth=1; ctx.stroke();

  // === PISTOL GRIP ===
  ctx.save();
  ctx.translate(30,10); ctx.rotate(0.22);
  const pgG = ctx.createLinearGradient(-13,0,13,0);
  pgG.addColorStop(0,'#3a1a08'); pgG.addColorStop(0.5,'#5a2c10'); pgG.addColorStop(1,'#2a1205');
  ctx.fillStyle=pgG;
  ctx.beginPath(); ctx.roundRect(-13,0,28,52,6); ctx.fill();
  ctx.strokeStyle='#1a0a04'; ctx.lineWidth=1; ctx.stroke();
  // grip stippling
  ctx.fillStyle='rgba(0,0,0,0.25)';
  for(let gx=0;gx<4;gx++) for(let gy=0;gy<7;gy++){
    ctx.beginPath(); ctx.arc(-8+gx*6,6+gy*6,1.2,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // trigger guard
  ctx.beginPath(); ctx.arc(18,14,16,0.15,Math.PI-0.15);
  ctx.strokeStyle='#9a6018'; ctx.lineWidth=3; ctx.stroke();
  // trigger
  ctx.fillStyle='#7a4010';
  ctx.beginPath(); ctx.ellipse(16,16,3.5,8,0.18,0,Math.PI*2); ctx.fill();

  // === MUZZLE DEVICE (vlaai-inspired) ===
  // muzzle brake / compensator
  const muzzG = ctx.createLinearGradient(-160,-16,-160,16);
  muzzG.addColorStop(0,'#c89030'); muzzG.addColorStop(1,'#8a5818');
  ctx.fillStyle=muzzG;
  ctx.beginPath(); ctx.roundRect(-168,-16,14,32,3); ctx.fill();
  ctx.strokeStyle='#5a3008'; ctx.lineWidth=1.5; ctx.stroke();
  // muzzle slots (vents for vlaai launch)
  ctx.fillStyle='#1a0800';
  for(let ms=0;ms<3;ms++){ ctx.fillRect(-166,-10+ms*8,10,5); }

  // muzzle face â€“ circular with vlaai pattern
  const mfG = ctx.createRadialGradient(-168,0,2,-168,0,14);
  mfG.addColorStop(0,'#1a0800'); mfG.addColorStop(0.6,'#6a3808'); mfG.addColorStop(1,'#c08020');
  ctx.fillStyle=mfG;
  ctx.beginPath(); ctx.arc(-168,0,14,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#3a1a04'; ctx.lineWidth=2; ctx.stroke();
  // bore
  ctx.fillStyle='#080400';
  ctx.beginPath(); ctx.arc(-168,0,7,0,Math.PI*2); ctx.fill();
  // vlaai wedge pattern around bore
  ctx.strokeStyle='rgba(210,160,20,0.7)'; ctx.lineWidth=1.5;
  for(let mv=0;mv<8;mv++){
    const ma=mv*Math.PI/4;
    ctx.beginPath(); ctx.moveTo(-168+Math.cos(ma)*7,Math.sin(ma)*7);
    ctx.lineTo(-168+Math.cos(ma)*13,Math.sin(ma)*13); ctx.stroke();
  }

  // === VLAAI MAGAZINE on bottom ===
  const magG = ctx.createLinearGradient(0,14,0,38);
  magG.addColorStop(0,'#c8860a'); magG.addColorStop(1,'#7a4808');
  ctx.fillStyle=magG;
  ctx.beginPath(); ctx.roundRect(-60,14,36,32,5); ctx.fill();
  ctx.strokeStyle='#5a3005'; ctx.lineWidth=1.5; ctx.stroke();
  // mini vlaai on mag
  ctx.save();
  ctx.translate(-42,28); ctx.scale(0.28,0.28);
  ctx.drawImage(VLAAI_C,-32,-32,64,64);
  ctx.restore();
  // mag label
  ctx.fillStyle='rgba(255,200,50,0.8)';
  ctx.font='bold 7px monospace';
  ctx.fillText('VLAAI',ctx.measureText('VLAAI').width>0?-68:-68,20);

  ctx.restore(); // rifle

  // â”€â”€ Trigger hand & forearm (on top of rifle) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.save();
  ctx.rotate(-0.12);

  // white shirt sleeve
  const slG = ctx.createLinearGradient(-38,0,38,0);
  slG.addColorStop(0,'#cccccc'); slG.addColorStop(0.45,'#f8f8f8'); slG.addColorStop(1,'#c0c0c0');
  ctx.fillStyle=slG;
  ctx.beginPath();
  ctx.moveTo(-40,0); ctx.lineTo(40,0);
  ctx.lineTo(36,-130); ctx.lineTo(-36,-130);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='#b8b8b8'; ctx.lineWidth=1; ctx.stroke();
  // button-down shirt detail lines
  ctx.strokeStyle='rgba(180,180,180,0.6)'; ctx.lineWidth=0.8;
  ctx.beginPath(); ctx.moveTo(2,0); ctx.lineTo(2,-130); ctx.stroke();
  // cuff
  const cuffG=ctx.createLinearGradient(-38,-138,38,-138);
  cuffG.addColorStop(0,'#d0d0d0'); cuffG.addColorStop(0.5,'#eeeeee'); cuffG.addColorStop(1,'#c8c8c8');
  ctx.fillStyle=cuffG; ctx.fillRect(-38,-142,76,14);
  ctx.strokeStyle='#b0b0b0'; ctx.lineWidth=1; ctx.strokeRect(-38,-142,76,14);
  // cuff button
  ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.arc(0,-135,2.5,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#bbb'; ctx.lineWidth=0.8; ctx.stroke();

  // hand
  const skinG = ctx.createRadialGradient(-5,-158,4,0,-155,30);
  skinG.addColorStop(0,'#f0c090'); skinG.addColorStop(1,'#c88858');
  ctx.beginPath(); ctx.ellipse(0,-157,26,22,0,0,Math.PI*2);
  ctx.fillStyle=skinG; ctx.fill();

  // knuckles
  for(let fi=0;fi<4;fi++){
    const fx=-14+fi*9, fy=-147;
    ctx.beginPath(); ctx.ellipse(fx,fy,4,6,0.08*fi,0,Math.PI*2);
    ctx.fillStyle=`rgb(${185+fi*5},${138+fi*4},${88+fi*3})`; ctx.fill();
    ctx.strokeStyle='rgba(130,85,45,0.25)'; ctx.lineWidth=0.8; ctx.stroke();
    // knuckle crease
    ctx.strokeStyle='rgba(100,60,30,0.2)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(fx-3,fy-2); ctx.lineTo(fx+3,fy-2); ctx.stroke();
  }
  // thumb
  ctx.beginPath(); ctx.ellipse(-22,-163,5.5,8,0.65,0,Math.PI*2);
  ctx.fillStyle='#d4a070'; ctx.fill();
  // fingernail hint
  ctx.fillStyle='rgba(255,230,200,0.5)';
  for(let fi=0;fi<4;fi++){
    const fx=-14+fi*9;
    ctx.beginPath(); ctx.ellipse(fx,-141,2.5,1.5,0,0,Math.PI*2); ctx.fill();
  }
  // subtle stubble on back of hand
  ctx.fillStyle='rgba(80,50,20,0.12)';
  for(let sh=0;sh<12;sh++){
    const hx=-18+sh*3, hy=-165+sh%3*3;
    ctx.beginPath(); ctx.arc(hx,hy,0.8,0,Math.PI*2); ctx.fill();
  }

  ctx.restore(); // hand

  ctx.restore(); // main AX/AY translate

  // muzzle flash
  if(P.recoil>0.5){
    const fa=(P.recoil-0.5)/0.5;
    const muzzX=AX-228, muzzY=AY-163;
    ctx.save();
    ctx.globalAlpha=fa*0.9;
    // main flash
    const fl=ctx.createRadialGradient(muzzX,muzzY,0,muzzX,muzzY,38);
    fl.addColorStop(0,'#ffffff'); fl.addColorStop(0.25,'#ffee88'); fl.addColorStop(0.6,'#ff8800'); fl.addColorStop(1,'rgba(255,60,0,0)');
    ctx.fillStyle=fl; ctx.beginPath(); ctx.arc(muzzX,muzzY,38,0,Math.PI*2); ctx.fill();
    // vlaai-shaped flash rays
    ctx.strokeStyle='rgba(255,220,80,0.7)'; ctx.lineWidth=2;
    for(let fr=0;fr<6;fr++){
      const fa2=fr*Math.PI/3;
      ctx.beginPath(); ctx.moveTo(muzzX+Math.cos(fa2)*8,muzzY+Math.sin(fa2)*8);
      ctx.lineTo(muzzX+Math.cos(fa2)*32,muzzY+Math.sin(fa2)*32); ctx.stroke();
    }
    ctx.globalAlpha=1;
    ctx.restore();
  }
}

// â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addParticles(wx, wy, n, colors) {
  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2, s=1+Math.random()*3;
    particles.push({
      x:wx, y:wy,
      vx:Math.cos(a)*s, vy:Math.sin(a)*s,
      life:1, decay:0.03+Math.random()*0.04,
      color:colors[Math.floor(Math.random()*colors.length)],
      size:4+Math.random()*8, rot:Math.random()*Math.PI*2, rv:(Math.random()-0.5)*0.2
    });
  }
}

// â”€â”€ Spawning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SPAWN_TILES=[
  [1,1],[1,18],[18,1],[18,18],
  [1,9],[18,9],[9,1],[9,18],
  [5,1],[14,1],[5,18],[14,18],
];
function spawnRobot(){
  const t=SPAWN_TILES[Math.floor(Math.random()*SPAWN_TILES.length)];
  const rx=t[0]*CELL+CELL/2+(Math.random()-0.5)*20;
  const ry=t[1]*CELL+CELL/2+(Math.random()-0.5)*20;
  const vi=robotVariant(wave);
  // each variant has different stats
  const baseHp=[1,2,4,8][vi];
  const baseSpd=[0.9,0.6,0.38,0.28][vi];
  const sizeScale=[0.7,1.0,1.4,1.9][vi];
  const hp=baseHp+Math.floor(wave*0.4);
  robots.push({x:rx,y:ry,hp,maxHp:hp,
    speed:baseSpd+wave*0.04+Math.random()*0.2,
    sizeScale, variant:vi,
    hitT:0,dead:false,deathT:0});
}

// â”€â”€ Shoot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function shoot(){
  if(P.shootCD>0) return;
  P.shootCD=22; P.recoil=1;
  bullets.push({x:P.x,y:P.y,dx:Math.cos(P.angle)*5,dy:Math.sin(P.angle)*5,rot:0,life:180});
  sndShoot();
}

// â”€â”€ HUD face â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function(){
  const fc=document.createElement('canvas'); fc.width=fc.height=72;
  const g=fc.getContext('2d');
  // bg
  g.fillStyle='#111'; g.fillRect(0,0,72,72);
  // shirt
  const sg=g.createLinearGradient(10,72,62,72); sg.addColorStop(0,'#d8d8d8'); sg.addColorStop(0.5,'#f8f8f8'); sg.addColorStop(1,'#d0d0d0');
  g.fillStyle=sg;
  g.beginPath(); g.moveTo(8,72); g.lineTo(8,58); g.bezierCurveTo(8,46,30,44,36,44); g.bezierCurveTo(42,44,64,46,64,58); g.lineTo(64,72); g.closePath(); g.fill();
  // collar v-neck
  g.fillStyle='#c0c0c0'; g.beginPath(); g.moveTo(30,44); g.lineTo(36,50); g.lineTo(42,44); g.closePath(); g.fill();
  // neck
  const nk=g.createRadialGradient(36,50,2,36,50,10); nk.addColorStop(0,'#e8b880'); nk.addColorStop(1,'#c09060');
  g.fillStyle=nk; g.beginPath(); g.ellipse(36,50,8,9,0,0,Math.PI*2); g.fill();
  // face
  const fk=g.createRadialGradient(33,27,4,36,28,24); fk.addColorStop(0,'#f2c490'); fk.addColorStop(1,'#d4a06a');
  g.fillStyle=fk; g.beginPath(); g.ellipse(36,28,20,24,0,0,Math.PI*2); g.fill();
  // hair dark brown swept
  g.fillStyle='#281508';
  g.beginPath(); g.ellipse(36,12,21,13,0,0,Math.PI*2); g.fill();
  g.beginPath(); g.ellipse(19,20,9,11,0.4,0,Math.PI); g.fill();
  g.beginPath(); g.ellipse(53,20,9,11,-0.4,0,Math.PI); g.fill();
  g.strokeStyle='#180e04'; g.lineWidth=1.5;
  for(let i=0;i<5;i++){g.beginPath();g.moveTo(18+i*5,9);g.quadraticCurveTo(28+i*4,5,50+i*2,11);g.stroke();}
  // eyes blue-grey
  for(const ex of [-1,1]){
    g.fillStyle='#fff'; g.beginPath(); g.ellipse(36+ex*9,28,5,4,0,0,Math.PI*2); g.fill();
    const eg=g.createRadialGradient(36+ex*9,28,0,36+ex*9,28,3.5); eg.addColorStop(0,'#6a8aaa'); eg.addColorStop(1,'#3a5570');
    g.fillStyle=eg; g.beginPath(); g.arc(36+ex*9,28,3,0,Math.PI*2); g.fill();
    g.fillStyle='#050a10'; g.beginPath(); g.arc(36+ex*9,28,1.4,0,Math.PI*2); g.fill();
    g.fillStyle='rgba(255,255,255,0.7)'; g.beginPath(); g.arc(35+ex*9,27,0.6,0,Math.PI*2); g.fill();
    g.strokeStyle='#1c0e04'; g.lineWidth=1.8;
    g.beginPath(); g.moveTo(29+ex*9,23); g.quadraticCurveTo(36+ex*9,21,43+ex*9,23); g.stroke();
  }
  // nose
  g.strokeStyle='#a07040'; g.lineWidth=1.4;
  g.beginPath(); g.moveTo(34,29); g.quadraticCurveTo(32,35,35,37); g.quadraticCurveTo(37,37.5,39,37); g.stroke();
  // stubble
  g.fillStyle='rgba(70,40,15,0.18)';
  const sr=(seed)=>{let x=Math.sin(seed*77.7)*9999;return x-Math.floor(x);};
  for(let i=0;i<40;i++){g.beginPath();g.arc(24+sr(i)*22,38+sr(i+1)*10,0.9,0,Math.PI*2);g.fill();}
  // mouth
  g.strokeStyle='#986040'; g.lineWidth=1.6;
  g.beginPath(); g.moveTo(28,41); g.quadraticCurveTo(36,46,44,41); g.stroke();
  document.getElementById('hud-face').appendChild(fc);
})();

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(){
  if(!running) return;

  // rotation
  const rotSpd = P.ROT;
  // Rotation: AZERTY=QD, QWERTY=AD, arrows
  if(K['KeyA']||K['KeyQ']||K['ArrowLeft'])  P.angle -= rotSpd;
  if(K['KeyD']||K['ArrowRight']) P.angle += rotSpd;
  P.angle += mouseDX * 0.0035;
  mouseDX = 0;

  // Movement: AZERTY=ZQSD, QWERTY=WASD, arrows
  let movX=0, movY=0;
  if(K['KeyW']||K['KeyZ']||K['ArrowUp']){   movX+=Math.cos(P.angle); movY+=Math.sin(P.angle); }
  if(K['KeyS']||K['ArrowDown']){ movX-=Math.cos(P.angle); movY-=Math.sin(P.angle); }
  // strafe Q/E or not needed â€“ just WASD+mouse
  const spd = P.SPEED;
  const R = P.RADIUS;

  if(movX!==0||movY!==0){
    const len=Math.sqrt(movX*movX+movY*movY);
    const nx=movX/len*spd, ny=movY/len*spd;
    // try X
    if(walkable(P.x+nx+Math.sign(nx)*R, P.y)) P.x+=nx;
    // try Y
    if(walkable(P.x, P.y+ny+Math.sign(ny)*R)) P.y+=ny;
    P.bobT += 0.12;
  }
  P.bob = Math.sin(P.bobT)*4;

  // cooldowns
  P.shootCD = Math.max(0, P.shootCD-1);
  P.recoil  = Math.max(0, P.recoil-0.08);
  dmgFlash  = Math.max(0, dmgFlash-0.06);
  hitRed    = Math.max(0, hitRed-0.05);

  // bullets
  bullets = bullets.filter(b=>{
    b.x+=b.dx; b.y+=b.dy; b.rot+=0.18; b.life--;
    if(!walkable(b.x,b.y)){ addParticles(b.x,b.y,8,['#c8860a','#cc2222','#ffaa00']); return false; }
    let alive=true;
    for(const r of robots){
      if(r.dead) continue;
      const dx=r.x-b.x, dy=r.y-b.y;
      if(dx*dx+dy*dy < 30*30){
        r.hp--; r.hitT=6;
        addParticles(b.x,b.y,10,['#c8860a','#ff3300','#ffcc00']);
        sndHit();
        if(r.hp<=0){
          r.dead=true;
          P.score+=100*r.maxHp;
          addParticles(r.x,r.y,22,['#445566','#2a3a4a','#ff3300','#ffaa00']);
          sndDeath();
          flashKill();
        }
        alive=false; break;
      }
    }
    return alive&&b.life>0;
  });

  // robots
  for(const r of robots){
    if(r.dead){ r.deathT++; continue; }
    r.hitT=Math.max(0,r.hitT-1);
    const dx=P.x-r.x, dy=P.y-r.y;
    const d=Math.sqrt(dx*dx+dy*dy);
    if(d>18){
      const spd2=r.speed;
      const nx2=r.x+(dx/d)*spd2, ny2=r.y+(dy/d)*spd2;
      if(walkable(nx2,r.y)) r.x=nx2;
      if(walkable(r.x,ny2)) r.y=ny2;
    }
    if(d<26){
      P.hp-=0.06; hitRed=1; dmgFlash=1;
      if(Math.random()<0.012) sndDamage(); // occasional yelp, not every frame
      if(P.hp<=0){ endGame(); return; }
    }
  }
  robots=robots.filter(r=>!r.dead||r.deathT<30);

  // particles (world space â€“ we don't render them in 3D, skip for simplicity)
  particles=particles.filter(p=>{ p.x+=p.vx; p.y+=p.vy; p.life-=p.decay; p.rot+=p.rv; return p.life>0; });

  // wave
  waveTimer++;
  if(robots.filter(r=>!r.dead).length===0&&waveTimer>120){
    wave++;
    waveTimer=0;
    const cnt=Math.min(12,2+wave);
    for(let i=0;i<cnt;i++) setTimeout(spawnRobot,i*350);
    flashWave();
  }

  // update HUD DOM
  document.getElementById('hHp').textContent    = Math.max(0,Math.floor(P.hp));
  document.getElementById('hScore').textContent  = P.score;
  document.getElementById('hWave').textContent   = wave;

  // fade kill/wave msgs
  killMsgT=Math.max(0,killMsgT-0.02);
  waveMsgT=Math.max(0,waveMsgT-0.015);
  document.getElementById('killmsg').style.opacity=killMsgT;
  document.getElementById('wavemsg').style.opacity=waveMsgT;
}

function flashKill(){
  const msgs=['ROBOT NEER!','VLAAI RAAK!','GECRASHT!','STUK!','LEKKER!','OP DE KORREL!'];
  document.getElementById('killmsg').textContent=msgs[Math.floor(Math.random()*msgs.length)];
  killMsgT=2.5;
}
function flashWave(){
  document.getElementById('wavemsg').textContent=`âš¡ GOLF ${wave} âš¡`;
  waveMsgT=3.5;
  sndWave();
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render(){
  renderWalls(P.bob);
  renderSprites(P.bob);
  renderWeapon();

  // damage vignette
  if(dmgFlash>0){
    const dv=ctx.createRadialGradient(RW/2,RH/2,RH*0.08,RW/2,RH/2,RH*0.85);
    dv.addColorStop(0,'transparent');
    dv.addColorStop(1,`rgba(255,0,0,${(dmgFlash*0.65).toFixed(2)})`);
    ctx.fillStyle=dv; ctx.fillRect(0,0,RW,RH);
  }

  // crosshair
  const cx=RW/2, cy=RH/2;
  ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.lineWidth=1.5;
  ctx.shadowBlur=3; ctx.shadowColor='#000';
  ctx.beginPath(); ctx.moveTo(cx-14,cy); ctx.lineTo(cx-4,cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+4,cy);  ctx.lineTo(cx+14,cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy-14); ctx.lineTo(cx,cy-4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy+4);  ctx.lineTo(cx,cy+14); ctx.stroke();
  ctx.fillStyle='rgba(255,60,0,0.9)'; ctx.shadowColor='#ff4400'; ctx.shadowBlur=6;
  ctx.beginPath(); ctx.arc(cx,cy,2,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;

  // minimap (top-left)
  drawMinimap();
}

function drawMinimap(){
  const MS=90, cs=MS/Math.max(MW,MH);
  const ox=8, oy=8;
  ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(ox,oy,MS,MS);
  for(let r=0;r<MH;r++) for(let c=0;c<MW;c++){
    const t=MAP[r][c];
    if(!t) continue;
    const colors=['','#5a3a28','#2a4a6a','#2a3a20','#200000','#071018'];
    ctx.fillStyle=colors[t]||'#555';
    ctx.fillRect(ox+c*cs,oy+r*cs,cs,cs);
  }
  // player dot + direction
  const px=ox+P.x/CELL*cs, py=oy+P.y/CELL*cs;
  ctx.fillStyle='#00ff88';
  ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#00ff88'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px+Math.cos(P.angle)*8,py+Math.sin(P.angle)*8); ctx.stroke();
  // robots
  for(const r of robots){
    if(r.dead) continue;
    ctx.fillStyle='#ff2200';
    ctx.beginPath(); ctx.arc(ox+r.x/CELL*cs,oy+r.y/CELL*cs,2,0,Math.PI*2); ctx.fill();
  }
  ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=0.5;
  ctx.strokeRect(ox,oy,MS,MS);
}

// â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop(){
  if(!running) return;
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function startGame(){
  document.getElementById('overlay').style.display='none';
  document.getElementById('gameover').style.display='none';
  document.getElementById('hud').style.display='flex';

  P.x=2*CELL+CELL/2; P.y=2*CELL+CELL/2;
  P.angle=0.5; P.hp=100; P.score=0;
  P.bobT=0; P.bob=0; P.shootCD=0; P.recoil=0;
  robots=[]; bullets=[]; particles=[];
  wave=1; waveTimer=0; dmgFlash=0; hitRed=0;
  killMsgT=0; waveMsgT=0;
  running=true;

  for(let i=0;i<3;i++) setTimeout(spawnRobot,i*400);
  flashWave();
  startAmbient();
  canvas.requestPointerLock();
  requestAnimationFrame(gameLoop);
}

// â”€â”€ Scoreboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Uses localStorage as primary storage + optional cloud backend.
// To enable online scores: replace CLOUD_URL with your own endpoint
// (e.g. a free Supabase REST, PocketBase, or any JSON API).
// The endpoint should accept GET (returns [{name,score,date},...]) and
// POST (body: {name,score,date}) â€“ or set CLOUD_URL=null for local-only.
const SUPABASE_URL = 'https://bmcqxbpzkmrtvfzunvap.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJtY3F4YnB6a21ydHZmenVudmFwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0MjA3NzQsImV4cCI6MjA4Njk5Njc3NH0.w07JFL5f_Iv9pt5R84G8HIrhkg9lDZ84umvCTxKZqm8';
const CLOUD_URL = `${SUPABASE_URL}/rest/v1/scores`;

// Bad word list + Wouter blocking
const BLOCKED_PATTERNS = [
  /wouter/i,
  /\bfuck\b/i, /\bshit\b/i, /\bcunt\b/i, /\bdick\b/i, /\bass\b/i,
  /\bkut\b/i, /\bfikker\b/i, /\bnigger\b/i, /\blul\b/i, /\bhoer\b/i,
  /\bnazi\b/i, /\bhitler\b/i, /\bsex\b/i, /\bporno\b/i, /\bpenis\b/i,
  /\bvagina\b/i, /\bbitch\b/i, /\bstom\b.*\bwou/i,
];
function isNameOk(name) {
  const n=name.trim();
  if(n.length<2) return 'Naam te kort!';
  if(n.length>20) return 'Naam te lang!';
  for(const p of BLOCKED_PATTERNS) if(p.test(n)) return 'Die naam is niet toegestaan ğŸ™…';
  return null; // ok
}

function getLocalScores() {
  try { return JSON.parse(localStorage.getItem('vlaaiScores')||'[]'); } catch(e){ return []; }
}
function saveLocalScore(name, score) {
  const scores=getLocalScores();
  scores.push({name:name.trim(), score, date: new Date().toLocaleDateString('nl-BE')});
  scores.sort((a,b)=>b.score-a.score);
  const top=scores.slice(0,50);
  localStorage.setItem('vlaaiScores', JSON.stringify(top));
  return top;
}

const SB_HEADERS = {
  'apikey': SUPABASE_KEY,
  'Authorization': `Bearer ${SUPABASE_KEY}`,
  'Content-Type': 'application/json',
  'Prefer': 'return=minimal',
};

async function fetchCloudScores() {
  if(!CLOUD_URL) return null;
  try {
    const r=await fetch(
      `${CLOUD_URL}?select=name,score,date&order=score.desc&limit=50`,
      { headers: { ...SB_HEADERS, 'Prefer': 'return=representation' } }
    );
    if(!r.ok) return null;
    return await r.json(); // [{name, score, date}, ...]
  } catch(e){ return null; }
}
async function postCloudScore(name, score) {
  if(!CLOUD_URL) return false;
  try {
    const r=await fetch(CLOUD_URL, {
      method:'POST',
      headers: SB_HEADERS,
      body: JSON.stringify({name:name.trim(), score, date: new Date().toLocaleDateString('nl-BE')})
    });
    return r.ok;
  } catch(e){ return false; }
}

function renderScoreList(scores) {
  const el=document.getElementById('scoreList');
  if(!scores||scores.length===0){ el.innerHTML='<span style="color:#555">Nog geen scores...</span>'; return; }
  el.innerHTML=scores.slice(0,15).map((s,i)=>{
    const medal=['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][i]||`${i+1}.`;
    const name=s.name.replace(/</g,'&lt;');
    const highlight=i===0?'color:#ffcc00':'';
    return `<div style="display:flex;justify-content:space-between;gap:16px;padding:2px 0;${highlight}">
      <span>${medal} ${name}</span><span>${s.score.toLocaleString()}</span><span style="color:#555;font-size:11px">${s.date||''}</span>
    </div>`;
  }).join('');
}

async function loadScores() {
  const cloud=await fetchCloudScores();
  renderScoreList(cloud||getLocalScores());
}

async function submitScore() {
  const nameEl=document.getElementById('playerName');
  const msgEl=document.getElementById('scoreMsg');
  const name=nameEl.value;
  const err=isNameOk(name);
  if(err){ msgEl.style.color='#ff4400'; msgEl.textContent=err; return; }
  msgEl.style.color='#aaa'; msgEl.textContent='Opslaan...';
  const local=saveLocalScore(name, P.score);
  renderScoreList(local);
  const cloud=await postCloudScore(name, P.score);
  if(CLOUD_URL){
    if(cloud){ msgEl.textContent='âœ… Score opgeslagen!'; await loadScores(); }
    else      { msgEl.textContent='âš  Offline â€“ lokaal opgeslagen'; }
  } else {
    msgEl.textContent='âœ… Score lokaal opgeslagen! (zie instellingen voor online)';
  }
  nameEl.disabled=true;
  document.querySelector('#nameEntry button').disabled=true;
}

function endGame(){
  running=false;
  stopAmbient();
  document.getElementById('hud').style.display='none';
  document.getElementById('finalScore').textContent=P.score.toLocaleString();
  document.getElementById('gameover').style.display='flex';
  document.getElementById('scoreMsg').textContent='';
  // reset name entry
  const ni=document.getElementById('playerName');
  ni.value=''; ni.disabled=false;
  document.querySelector('#nameEntry button').disabled=false;
  document.exitPointerLock();
  loadScores();
}
</script>
</body>
</html>
